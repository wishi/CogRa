# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_digital_swig', [dirname(__file__)])
        except ImportError:
            import _digital_swig
            return _digital_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_digital_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _digital_swig = swig_import_helper()
    del swig_import_helper
else:
    import _digital_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_decr(self, n)

    def distance(self, *args, **kwargs):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _digital_swig.SwigPyIterator_distance(self, *args, **kwargs)

    def equal(self, *args, **kwargs):
        """equal(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator_equal(self, *args, **kwargs)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _digital_swig.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_previous(self)

    def advance(self, *args, **kwargs):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_advance(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator___ne__(self, *args, **kwargs)

    def __iadd__(self, *args, **kwargs):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___iadd__(self, *args, **kwargs)

    def __isub__(self, *args, **kwargs):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___isub__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___add__(self, *args, **kwargs)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _digital_swig.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _digital_swig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SNR_EST_SIMPLE = _digital_swig.SNR_EST_SIMPLE
SNR_EST_SKEW = _digital_swig.SNR_EST_SKEW
SNR_EST_M2M4 = _digital_swig.SNR_EST_M2M4
SNR_EST_SVR = _digital_swig.SNR_EST_SVR
class gri_control_loop(object):
    """Proxy of C++ gri_control_loop class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, float loop_bw, float max_freq, float min_freq) -> gri_control_loop"""
        this = _digital_swig.new_gri_control_loop(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_gri_control_loop
    __del__ = lambda self : None;
    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.gri_control_loop_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.gri_control_loop_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.gri_control_loop_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.gri_control_loop_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.gri_control_loop_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.gri_control_loop_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.gri_control_loop_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.gri_control_loop_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.gri_control_loop_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.gri_control_loop_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.gri_control_loop_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.gri_control_loop_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.gri_control_loop_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.gri_control_loop_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.gri_control_loop_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.gri_control_loop_get_phase(self)

gri_control_loop_swigregister = _digital_swig.gri_control_loop_swigregister
gri_control_loop_swigregister(gri_control_loop)

class digital_binary_slicer_fb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_binary_slicer_fb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_binary_slicer_fb_sptr
        __init__(self,  p) -> digital_binary_slicer_fb_sptr
        """
        this = _digital_swig.new_digital_binary_slicer_fb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_binary_slicer_fb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_binary_slicer_fb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_binary_slicer_fb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_binary_slicer_fb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_binary_slicer_fb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_binary_slicer_fb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_binary_slicer_fb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_binary_slicer_fb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_binary_slicer_fb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_binary_slicer_fb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_check_topology(self, *args, **kwargs)

digital_binary_slicer_fb_sptr_swigregister = _digital_swig.digital_binary_slicer_fb_sptr_swigregister
digital_binary_slicer_fb_sptr_swigregister(digital_binary_slicer_fb_sptr)

digital_binary_slicer_fb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def binary_slicer_fb():
  """
    binary_slicer_fb() -> digital_binary_slicer_fb_sptr

    slice float binary symbol outputting 1 bit output

    x < 0 --> 0 x >= 0 --> 1

    Params: (NONE)
    """
  return _digital_swig.binary_slicer_fb()
class digital_clock_recovery_mm_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_clock_recovery_mm_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_clock_recovery_mm_cc_sptr
        __init__(self,  p) -> digital_clock_recovery_mm_cc_sptr
        """
        this = _digital_swig.new_digital_clock_recovery_mm_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_clock_recovery_mm_cc_sptr
    __del__ = lambda self : None;
    def mu(self):
        """
        mu(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_mu(self)

    def omega(self):
        """
        omega(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_omega(self)

    def gain_mu(self):
        """
        gain_mu(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_gain_omega(self)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(self, float gain_mu)

        Params: (gain_mu)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(self, float gain_omega)

        Params: (gain_omega)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(self, float omega)

        Params: (mu)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(self, float omega)

        Params: (omega)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_omega(self, *args, **kwargs)

    def set_verbose(self, *args, **kwargs):
        """
        set_verbose(self, bool verbose)

        Params: (verbose)
        """
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_verbose(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_check_topology(self, *args, **kwargs)

digital_clock_recovery_mm_cc_sptr_swigregister = _digital_swig.digital_clock_recovery_mm_cc_sptr_swigregister
digital_clock_recovery_mm_cc_sptr_swigregister(digital_clock_recovery_mm_cc_sptr)

digital_clock_recovery_mm_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def clock_recovery_mm_cc(*args, **kwargs):
  """
    clock_recovery_mm_cc(float omega, float gain_omega, float mu, float gain_mu, 
        float omega_relative_limit) -> digital_clock_recovery_mm_cc_sptr

    Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    The complex version here is based on: Modified Mueller and Muller clock recovery circuit Based: G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
        and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

    Params: (omega, gain_omega, mu, gain_mu, omega_relative_limi)
    """
  return _digital_swig.clock_recovery_mm_cc(*args, **kwargs)
class digital_clock_recovery_mm_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_clock_recovery_mm_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_clock_recovery_mm_ff_sptr
        __init__(self,  p) -> digital_clock_recovery_mm_ff_sptr
        """
        this = _digital_swig.new_digital_clock_recovery_mm_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_clock_recovery_mm_ff_sptr
    __del__ = lambda self : None;
    def mu(self):
        """
        mu(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_mu(self)

    def omega(self):
        """
        omega(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_omega(self)

    def gain_mu(self):
        """
        gain_mu(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_gain_omega(self)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(self, float gain_mu)

        Params: (gain_mu)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(self, float gain_omega)

        Params: (gain_omega)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(self, float omega)

        Params: (mu)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(self, float omega)

        Params: (omega)
        """
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_omega(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_check_topology(self, *args, **kwargs)

digital_clock_recovery_mm_ff_sptr_swigregister = _digital_swig.digital_clock_recovery_mm_ff_sptr_swigregister
digital_clock_recovery_mm_ff_sptr_swigregister(digital_clock_recovery_mm_ff_sptr)

digital_clock_recovery_mm_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def clock_recovery_mm_ff(*args, **kwargs):
  """
    clock_recovery_mm_ff(float omega, float gain_omega, float mu, float gain_mu, 
        float omega_relative_limit = 0.001) -> digital_clock_recovery_mm_ff_sptr

    Mueller and M?ller (M&M) based clock recovery block with float input, float output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    See "Digital Communication Receivers: Synchronization, Channel
     Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.

    Params: (omega, gain_omega, mu, gain_mu, omega_relative_limit)
    """
  return _digital_swig.clock_recovery_mm_ff(*args, **kwargs)
class digital_cma_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_cma_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_cma_equalizer_cc_sptr
        __init__(self,  p) -> digital_cma_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_cma_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_cma_equalizer_cc_sptr
    __del__ = lambda self : None;
    def get_gain(self):
        """
        get_gain(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_cma_equalizer_cc_sptr_get_gain(self)

    def set_gain(self, *args, **kwargs):
        """
        set_gain(self, float mu)

        Params: (mu)
        """
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def get_modulus(self):
        """
        get_modulus(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_cma_equalizer_cc_sptr_get_modulus(self)

    def set_modulus(self, *args, **kwargs):
        """
        set_modulus(self, float mod)

        Params: (mod)
        """
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_modulus(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, gr_complex_vector taps)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_cma_equalizer_cc_sptr_swigregister = _digital_swig.digital_cma_equalizer_cc_sptr_swigregister
digital_cma_equalizer_cc_sptr_swigregister(digital_cma_equalizer_cc_sptr)

digital_cma_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def cma_equalizer_cc(*args, **kwargs):
  """
    cma_equalizer_cc(int num_taps, float modulus, float mu, int sps) -> digital_cma_equalizer_cc_sptr

    Implements constant modulus adaptive filter on complex stream

    The error value and tap update equations (for p=2) can be found in:

    D. Godard, "Self-Recovering Equalization and Carrier Tracking in
     Two-Dimensional Data Communication Systems," IEEE Transactions on Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980,

    Params: (num_taps, modulus, mu, sps)
    """
  return _digital_swig.cma_equalizer_cc(*args, **kwargs)
class gr_complex_vector(object):
    """Proxy of C++ std::vector<(gr_complex)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class.
        """
        return _digital_swig.gr_complex_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _digital_swig.gr_complex_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _digital_swig.gr_complex_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _digital_swig.gr_complex_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _digital_swig.gr_complex_vector_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(self, difference_type i, difference_type j) -> __dummy_6__"""
        return _digital_swig.gr_complex_vector___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """__setslice__(self, difference_type i, difference_type j, __dummy_6__ v = std::vector< std::complex< float >,std::allocator< std::complex< float > > >())"""
        return _digital_swig.gr_complex_vector___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _digital_swig.gr_complex_vector___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _digital_swig.gr_complex_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> __dummy_6__
        __getitem__(self, difference_type i) -> value_type
        """
        return _digital_swig.gr_complex_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, __dummy_6__ v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _digital_swig.gr_complex_vector___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, value_type x)"""
        return _digital_swig.gr_complex_vector_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _digital_swig.gr_complex_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _digital_swig.gr_complex_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _digital_swig.gr_complex_vector_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, gr_complex_vector v)"""
        return _digital_swig.gr_complex_vector_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _digital_swig.gr_complex_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _digital_swig.gr_complex_vector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _digital_swig.gr_complex_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _digital_swig.gr_complex_vector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _digital_swig.gr_complex_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _digital_swig.gr_complex_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _digital_swig.gr_complex_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> gr_complex_vector
        __init__(self, gr_complex_vector arg0) -> gr_complex_vector
        __init__(self, size_type size) -> gr_complex_vector
        __init__(self, size_type size, value_type value) -> gr_complex_vector
        """
        this = _digital_swig.new_gr_complex_vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, value_type x)"""
        return _digital_swig.gr_complex_vector_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> value_type"""
        return _digital_swig.gr_complex_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _digital_swig.gr_complex_vector_back(self)

    def assign(self, *args, **kwargs):
        """assign(self, size_type n, value_type x)"""
        return _digital_swig.gr_complex_vector_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _digital_swig.gr_complex_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _digital_swig.gr_complex_vector_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, size_type n)"""
        return _digital_swig.gr_complex_vector_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _digital_swig.gr_complex_vector_capacity(self)

    __swig_destroy__ = _digital_swig.delete_gr_complex_vector
    __del__ = lambda self : None;
gr_complex_vector_swigregister = _digital_swig.gr_complex_vector_swigregister
gr_complex_vector_swigregister(gr_complex_vector)

class unsigned_int_vector(object):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        STL iterator class.
        """
        return _digital_swig.unsigned_int_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _digital_swig.unsigned_int_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _digital_swig.unsigned_int_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _digital_swig.unsigned_int_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(self, difference_type i, difference_type j) -> unsigned_int_vector"""
        return _digital_swig.unsigned_int_vector___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """__setslice__(self, difference_type i, difference_type j, unsigned_int_vector v = std::vector< unsigned int,std::allocator< unsigned int > >())"""
        return _digital_swig.unsigned_int_vector___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _digital_swig.unsigned_int_vector___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _digital_swig.unsigned_int_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> unsigned_int_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _digital_swig.unsigned_int_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, unsigned_int_vector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _digital_swig.unsigned_int_vector___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, value_type x)"""
        return _digital_swig.unsigned_int_vector_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _digital_swig.unsigned_int_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _digital_swig.unsigned_int_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _digital_swig.unsigned_int_vector_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, unsigned_int_vector v)"""
        return _digital_swig.unsigned_int_vector_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _digital_swig.unsigned_int_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _digital_swig.unsigned_int_vector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _digital_swig.unsigned_int_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _digital_swig.unsigned_int_vector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _digital_swig.unsigned_int_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _digital_swig.unsigned_int_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _digital_swig.unsigned_int_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> unsigned_int_vector
        __init__(self, unsigned_int_vector arg0) -> unsigned_int_vector
        __init__(self, size_type size) -> unsigned_int_vector
        __init__(self, size_type size, value_type value) -> unsigned_int_vector
        """
        this = _digital_swig.new_unsigned_int_vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, value_type x)"""
        return _digital_swig.unsigned_int_vector_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_back(self)

    def assign(self, *args, **kwargs):
        """assign(self, size_type n, value_type x)"""
        return _digital_swig.unsigned_int_vector_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _digital_swig.unsigned_int_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _digital_swig.unsigned_int_vector_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, size_type n)"""
        return _digital_swig.unsigned_int_vector_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _digital_swig.unsigned_int_vector_capacity(self)

    __swig_destroy__ = _digital_swig.delete_unsigned_int_vector
    __del__ = lambda self : None;
unsigned_int_vector_swigregister = _digital_swig.unsigned_int_vector_swigregister
unsigned_int_vector_swigregister(unsigned_int_vector)

TRELLIS_EUCLIDEAN = _digital_swig.TRELLIS_EUCLIDEAN
TRELLIS_HARD_SYMBOL = _digital_swig.TRELLIS_HARD_SYMBOL
TRELLIS_HARD_BIT = _digital_swig.TRELLIS_HARD_BIT
class digital_constellation_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_sptr
        __init__(self, digital_constellation p) -> digital_constellation_sptr
        """
        this = _digital_swig.new_digital_constellation_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> digital_constellation"""
        return _digital_swig.digital_constellation_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_sptr_dimensionality(self)

digital_constellation_sptr_swigregister = _digital_swig.digital_constellation_sptr_swigregister
digital_constellation_sptr_swigregister(digital_constellation_sptr)

class digital_constellation(object):
    """
    An abstracted constellation object

    The constellation objects hold the necessary information to pass around constellation information for modulators and demodulators. These objects contain the mapping between the bits and the constellation points used to represent them as well as methods for slicing the symbol space. Various implementations are possible for efficiency and ease of use.

    Standard constellations (BPSK, QPSK, QAM, etc) can be inherited from this class and overloaded to perform optimized slicing and constellation mappings.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dimensionality(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation
    __del__ = lambda self : None;
digital_constellation_swigregister = _digital_swig.digital_constellation_swigregister
digital_constellation_swigregister(digital_constellation)

class digital_constellation_calcdist_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_calcdist)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_calcdist_sptr
        __init__(self,  p) -> digital_constellation_calcdist_sptr
        """
        this = _digital_swig.new_digital_constellation_calcdist_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_calcdist_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_calcdist_sptr
    __del__ = lambda self : None;
    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_decision_maker(self, *args, **kwargs)

    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_v_points(self)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_dimensionality(self)

digital_constellation_calcdist_sptr_swigregister = _digital_swig.digital_constellation_calcdist_sptr_swigregister
digital_constellation_calcdist_sptr_swigregister(digital_constellation_calcdist_sptr)


def constellation_calcdist(*args, **kwargs):
  """
    constellation_calcdist(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int rotational_symmetry, 
        unsigned int dimensionality) -> digital_constellation_calcdist_sptr

    Calculate Euclidian distance for any constellation

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.

    Params: (constellation, pre_diff_code, rotational_symmetry, dimensionality)
    """
  return _digital_swig.constellation_calcdist(*args, **kwargs)
class digital_constellation_sector(digital_constellation):
    """
    Sectorized digital constellation

    Constellation space is divided into sectors. Each sector is associated with the nearest constellation point.

    digital_constellation_sector
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_digital_constellation_sector
    __del__ = lambda self : None;
digital_constellation_sector_swigregister = _digital_swig.digital_constellation_sector_swigregister
digital_constellation_sector_swigregister(digital_constellation_sector)

class digital_constellation_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_rect_sptr
        __init__(self,  p) -> digital_constellation_rect_sptr
        """
        this = _digital_swig.new_digital_constellation_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_rect_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_rect_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_rect_sptr_dimensionality(self)

digital_constellation_rect_sptr_swigregister = _digital_swig.digital_constellation_rect_sptr_swigregister
digital_constellation_rect_sptr_swigregister(digital_constellation_rect_sptr)


def constellation_rect(*args, **kwargs):
  """
    constellation_rect(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int rotational_symmetry, 
        unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors) -> digital_constellation_rect_sptr

    Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
    """
  return _digital_swig.constellation_rect(*args, **kwargs)
class digital_constellation_psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_psk_sptr
        __init__(self,  p) -> digital_constellation_psk_sptr
        """
        this = _digital_swig.new_digital_constellation_psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_psk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_psk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_psk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_psk_sptr_dimensionality(self)

digital_constellation_psk_sptr_swigregister = _digital_swig.digital_constellation_psk_sptr_swigregister
digital_constellation_psk_sptr_swigregister(digital_constellation_psk_sptr)


def constellation_psk(*args, **kwargs):
  """
    constellation_psk(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int n_sectors) -> digital_constellation_psk_sptr

    digital_constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x

    Params: (constellation, pre_diff_code, n_sectors)
    """
  return _digital_swig.constellation_psk(*args, **kwargs)
class digital_constellation_bpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_bpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_bpsk_sptr
        __init__(self,  p) -> digital_constellation_bpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_bpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_bpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_bpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_dimensionality(self)

digital_constellation_bpsk_sptr_swigregister = _digital_swig.digital_constellation_bpsk_sptr_swigregister
digital_constellation_bpsk_sptr_swigregister(digital_constellation_bpsk_sptr)


def constellation_bpsk():
  """
    constellation_bpsk() -> digital_constellation_bpsk_sptr

    Digital constellation for BPSK.

    Params: (NONE)
    """
  return _digital_swig.constellation_bpsk()
class digital_constellation_qpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_qpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_qpsk_sptr
        __init__(self,  p) -> digital_constellation_qpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_qpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_qpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_qpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_dimensionality(self)

digital_constellation_qpsk_sptr_swigregister = _digital_swig.digital_constellation_qpsk_sptr_swigregister
digital_constellation_qpsk_sptr_swigregister(digital_constellation_qpsk_sptr)


def constellation_qpsk():
  """
    constellation_qpsk() -> digital_constellation_qpsk_sptr

    Digital constellation for QPSK.

    Params: (NONE)
    """
  return _digital_swig.constellation_qpsk()
class digital_constellation_dqpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_dqpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_dqpsk_sptr
        __init__(self,  p) -> digital_constellation_dqpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_dqpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_dqpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_dqpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_dimensionality(self)

digital_constellation_dqpsk_sptr_swigregister = _digital_swig.digital_constellation_dqpsk_sptr_swigregister
digital_constellation_dqpsk_sptr_swigregister(digital_constellation_dqpsk_sptr)


def constellation_dqpsk():
  """
    constellation_dqpsk() -> digital_constellation_dqpsk_sptr

    Digital constellation for DQPSK.

    Params: (NONE)
    """
  return _digital_swig.constellation_dqpsk()
class digital_constellation_8psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_8psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_8psk_sptr
        __init__(self,  p) -> digital_constellation_8psk_sptr
        """
        this = _digital_swig.new_digital_constellation_8psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_8psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_8psk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_8psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _digital_swig.digital_constellation_8psk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """
        map_to_points_v(self, unsigned int value) -> gr_complex_vector

        Params: (value)
        """
        return _digital_swig.digital_constellation_8psk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """
        bits_per_symbol(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_bits_per_symbol(self)

    def arity(self):
        """
        arity(self) -> unsigned int

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_arity(self)

    def base(self):
        """
        base(self) -> digital_constellation_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _digital_swig.digital_constellation_8psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _digital_swig.digital_constellation_8psk_sptr_dimensionality(self)

digital_constellation_8psk_sptr_swigregister = _digital_swig.digital_constellation_8psk_sptr_swigregister
digital_constellation_8psk_sptr_swigregister(digital_constellation_8psk_sptr)


def constellation_8psk():
  """
    constellation_8psk() -> digital_constellation_8psk_sptr

    Digital constellation for 8PSK.

    Params: (NONE)
    """
  return _digital_swig.constellation_8psk()
class digital_constellation_decoder_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_decoder_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_decoder_cb_sptr
        __init__(self,  p) -> digital_constellation_decoder_cb_sptr
        """
        this = _digital_swig.new_digital_constellation_decoder_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_decoder_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_decoder_cb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_check_topology(self, *args, **kwargs)

digital_constellation_decoder_cb_sptr_swigregister = _digital_swig.digital_constellation_decoder_cb_sptr_swigregister
digital_constellation_decoder_cb_sptr_swigregister(digital_constellation_decoder_cb_sptr)

digital_constellation_decoder_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def constellation_decoder_cb(*args, **kwargs):
  """
    constellation_decoder_cb(digital_constellation_sptr constellation) -> digital_constellation_decoder_cb_sptr

    Constellation Decoder.

    Params: (constellation)
    """
  return _digital_swig.constellation_decoder_cb(*args, **kwargs)
class digital_constellation_receiver_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_receiver_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_receiver_cb_sptr
        __init__(self,  p) -> digital_constellation_receiver_cb_sptr
        """
        this = _digital_swig.new_digital_constellation_receiver_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_receiver_cb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_phase(self)

digital_constellation_receiver_cb_sptr_swigregister = _digital_swig.digital_constellation_receiver_cb_sptr_swigregister
digital_constellation_receiver_cb_sptr_swigregister(digital_constellation_receiver_cb_sptr)

digital_constellation_receiver_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def constellation_receiver_cb(*args, **kwargs):
  """
    constellation_receiver_cb(digital_constellation_sptr constellation, float loop_bw, 
        float fmin, float fmax) -> digital_constellation_receiver_cb_sptr

    This block takes care of receiving generic modulated signals through phase, frequency, and symbol synchronization.

    This block takes care of receiving generic modulated signals through phase, frequency, and symbol synchronization. It performs carrier frequency and phase locking as well as symbol timing recovery.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
        and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

    Params: (constellation, loop_bw, fmin, fmax)
    """
  return _digital_swig.constellation_receiver_cb(*args, **kwargs)
class digital_correlate_access_code_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_correlate_access_code_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_correlate_access_code_bb_sptr
        __init__(self,  p) -> digital_correlate_access_code_bb_sptr
        """
        this = _digital_swig.new_digital_correlate_access_code_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_correlate_access_code_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_correlate_access_code_bb_sptr
    __del__ = lambda self : None;
    def set_access_code(self, *args, **kwargs):
        """
        set_access_code(self, string access_code) -> bool

        Params: (access_code)
        """
        return _digital_swig.digital_correlate_access_code_bb_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_check_topology(self, *args, **kwargs)

digital_correlate_access_code_bb_sptr_swigregister = _digital_swig.digital_correlate_access_code_bb_sptr_swigregister
digital_correlate_access_code_bb_sptr_swigregister(digital_correlate_access_code_bb_sptr)

digital_correlate_access_code_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def correlate_access_code_bb(*args, **kwargs):
  """
    correlate_access_code_bb(string access_code, int threshold) -> digital_correlate_access_code_bb_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

    Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.

    Params: (access_code, threshold)
    """
  return _digital_swig.correlate_access_code_bb(*args, **kwargs)
class digital_costas_loop_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_costas_loop_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_costas_loop_cc_sptr
        __init__(self,  p) -> digital_costas_loop_cc_sptr
        """
        this = _digital_swig.new_digital_costas_loop_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_costas_loop_cc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_costas_loop_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_costas_loop_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_costas_loop_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_costas_loop_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_costas_loop_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_costas_loop_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_costas_loop_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_costas_loop_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_phase(self)

digital_costas_loop_cc_sptr_swigregister = _digital_swig.digital_costas_loop_cc_sptr_swigregister
digital_costas_loop_cc_sptr_swigregister(digital_costas_loop_cc_sptr)

digital_costas_loop_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def costas_loop_cc(*args, **kwargs):
  """
    costas_loop_cc(float loop_bw, int order) -> digital_costas_loop_cc_sptr

    Carrier tracking PLL for QPSK

    input: complex; output: complex 
    The Costas loop can have two output streams: stream 1 is the baseband I and Q; stream 2 is the normalized frequency of the loop.

    must be 2 or 4.

    Params: (loop_bw, order)
    """
  return _digital_swig.costas_loop_cc(*args, **kwargs)

def update_crc32(*args, **kwargs):
  """
    update_crc32(unsigned int crc, string buf) -> unsigned int

    update running CRC-32

    Update a running CRC with the bytes buf[0..len-1] The CRC should be initialized to all 1's, and the transmitted value is the 1's complement of the final running CRC. The resulting CRC should be transmitted in big endian order.

    Params: (crc, buf, len)
    """
  return _digital_swig.update_crc32(*args, **kwargs)

def crc32(*args, **kwargs):
  """
    crc32(string buf) -> unsigned int

    Params: (buf, len)
    """
  return _digital_swig.crc32(*args, **kwargs)
class digital_fll_band_edge_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_fll_band_edge_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_fll_band_edge_cc_sptr
        __init__(self,  p) -> digital_fll_band_edge_cc_sptr
        """
        this = _digital_swig.new_digital_fll_band_edge_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_fll_band_edge_cc_sptr
    __del__ = lambda self : None;
    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_beta(self, *args, **kwargs)

    def set_samples_per_symbol(self, *args, **kwargs):
        """
        set_samples_per_symbol(self, float sps)

        Set the number of samples per symbol.

        Set's the number of samples per symbol the system should use. This value is uesd to calculate the filter taps and will force a recalculation.

        Params: (sps)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_samples_per_symbol(self, *args, **kwargs)

    def set_rolloff(self, *args, **kwargs):
        """
        set_rolloff(self, float rolloff)

        Set the rolloff factor of the shaping filter.

        This sets the rolloff factor that is used in the pulse shaping filter and is used to calculate the filter taps. Changing this will force a recalculation of the filter taps.

        This should be the same value that is used in the transmitter's pulse shaping filter. It must be between 0 and 1 and is usually between 0.2 and 0.5 (where 0.22 and 0.35 are commonly used values).

        Params: (rolloff)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_rolloff(self, *args, **kwargs)

    def set_filter_size(self, *args, **kwargs):
        """
        set_filter_size(self, int filter_size)

        Set the number of taps in the filter.

        This sets the number of taps in the band-edge filters. Setting this will force a recalculation of the filter taps.

        This should be about the same number of taps used in the transmitter's shaping filter and also not very large. A large number of taps will result in a large delay between input and frequency estimation, and so will not be as accurate. Between 30 and 70 taps is usual.

        Params: (filter_size)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_filter_size(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_beta(self)

    def get_samples_per_symbol(self):
        """
        get_samples_per_symbol(self) -> float

        Returns the number of sampler per symbol used for the filter.

        Params: (NONE)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_samples_per_symbol(self)

    def get_rolloff(self):
        """
        get_rolloff(self) -> float

        Returns the rolloff factor used for the filter.

        Params: (NONE)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_rolloff(self)

    def get_filter_size(self):
        """
        get_filter_size(self) -> int

        Returns the number of taps of the filter.

        Params: (NONE)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_filter_size(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_phase(self)

    def print_taps(self):
        """
        print_taps(self)

        Print the taps to screen.

        Params: (NONE)
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_print_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_frequency_limit(self)

digital_fll_band_edge_cc_sptr_swigregister = _digital_swig.digital_fll_band_edge_cc_sptr_swigregister
digital_fll_band_edge_cc_sptr_swigregister(digital_fll_band_edge_cc_sptr)

digital_fll_band_edge_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fll_band_edge_cc(*args, **kwargs):
  """
    fll_band_edge_cc(float samps_per_sym, float rolloff, int filter_size, 
        float bandwidth) -> digital_fll_band_edge_cc_sptr

    Frequency Lock Loop using band-edge filters.

    The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

    The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

    In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

    In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = rac{H(f)}{df}. In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

    Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

    It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

    Build the FLL

    Params: (samps_per_sym, rolloff, filter_size, bandwidth)
    """
  return _digital_swig.fll_band_edge_cc(*args, **kwargs)
class digital_kurtotic_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_kurtotic_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_kurtotic_equalizer_cc_sptr
        __init__(self,  p) -> digital_kurtotic_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_kurtotic_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_kurtotic_equalizer_cc_sptr
    __del__ = lambda self : None;
    def set_gain(self, *args, **kwargs):
        """
        set_gain(self, float mu)

        Params: (mu)
        """
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, gr_complex_vector taps)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_kurtotic_equalizer_cc_sptr_swigregister = _digital_swig.digital_kurtotic_equalizer_cc_sptr_swigregister
digital_kurtotic_equalizer_cc_sptr_swigregister(digital_kurtotic_equalizer_cc_sptr)

digital_kurtotic_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def kurtotic_equalizer_cc(*args, **kwargs):
  """
    kurtotic_equalizer_cc(int num_taps, float mu) -> digital_kurtotic_equalizer_cc_sptr

    Implements a kurtosis-based adaptive equalizer on complex stream

    Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind
     equalization algorithm," IEEE Conf. on Control, Automation, Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057.

    Params: (num_taps, mu)
    """
  return _digital_swig.kurtotic_equalizer_cc(*args, **kwargs)
class digital_lms_dd_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_lms_dd_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_lms_dd_equalizer_cc_sptr
        __init__(self,  p) -> digital_lms_dd_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_lms_dd_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_lms_dd_equalizer_cc_sptr
    __del__ = lambda self : None;
    def get_gain(self):
        """
        get_gain(self) -> float

        Params: (NONE)
        """
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_get_gain(self)

    def set_gain(self, *args, **kwargs):
        """
        set_gain(self, float mu)

        Params: (mu)
        """
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_lms_dd_equalizer_cc_sptr_swigregister = _digital_swig.digital_lms_dd_equalizer_cc_sptr_swigregister
digital_lms_dd_equalizer_cc_sptr_swigregister(digital_lms_dd_equalizer_cc_sptr)

digital_lms_dd_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def lms_dd_equalizer_cc(*args, **kwargs):
  """
    lms_dd_equalizer_cc(int num_taps, float mu, int sps, digital_constellation_sptr cnst) -> digital_lms_dd_equalizer_cc_sptr

    Least-Mean-Square Decision Directed Equalizer (complex in/out)

    This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update teh weight vector.

    y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

    Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

    This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like: self.constellation = digital.constellation_qpsk() To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

    The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.

    Params: (num_taps, mu, sps, cnst)
    """
  return _digital_swig.lms_dd_equalizer_cc(*args, **kwargs)
class digital_mpsk_receiver_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_mpsk_receiver_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_mpsk_receiver_cc_sptr
        __init__(self,  p) -> digital_mpsk_receiver_cc_sptr
        """
        this = _digital_swig.new_digital_mpsk_receiver_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_mpsk_receiver_cc_sptr
    __del__ = lambda self : None;
    def modulation_order(self):
        """
        modulation_order(self) -> float

        Returns the modulation order (M) currently set.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_modulation_order(self)

    def mu(self):
        """
        mu(self) -> float

        Returns current value of mu.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_mu(self)

    def omega(self):
        """
        omega(self) -> float

        Returns current value of omega.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_omega(self)

    def gain_mu(self):
        """
        gain_mu(self) -> float

        Returns mu gain factor.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(self) -> float

        Returns omega gain factor.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_omega(self)

    def gain_omega_rel(self):
        """
        gain_omega_rel(self) -> float

        Returns the relative omega limit.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_omega_rel(self)

    def set_modulation_order(self, *args, **kwargs):
        """
        set_modulation_order(self, unsigned int M)

        Sets the modulation order (M) currently.

        Params: (M)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_modulation_order(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(self, float mu)

        Sets value of mu.

        Params: (mu)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(self, float omega)

        Sets value of omega and its min and max values.

        Params: (omega)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_omega(self, *args, **kwargs)

    def set_theta(self, *args, **kwargs):
        """
        set_theta(self, float theta)

        Sets value of theta.

        Params: (theta)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_theta(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(self, float gain_mu)

        Sets value for mu gain factor.

        Params: (gain_mu)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(self, float gain_omega)

        Sets value for omega gain factor.

        Params: (gain_omega)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_gain_omega_rel(self, *args, **kwargs):
        """
        set_gain_omega_rel(self, float omega_rel)

        Sets the relative omega limit and resets omega min/max values.

        Params: (omega_rel)
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_omega_rel(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_phase(self)

digital_mpsk_receiver_cc_sptr_swigregister = _digital_swig.digital_mpsk_receiver_cc_sptr_swigregister
digital_mpsk_receiver_cc_sptr_swigregister(digital_mpsk_receiver_cc_sptr)

digital_mpsk_receiver_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def mpsk_receiver_cc(*args, **kwargs):
  """
    mpsk_receiver_cc(unsigned int M, float theta, float loop_bw, float fmin, 
        float fmax, float mu, float gain_mu, float omega, 
        float gain_omega, float omega_rel) -> digital_mpsk_receiver_cc_sptr

    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization. It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
        and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

    Params: (M, theta, loop_bw, fmin, fmax, mu, gain_mu, omega, gain_omega, omega_rel)
    """
  return _digital_swig.mpsk_receiver_cc(*args, **kwargs)
class digital_mpsk_snr_est_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_mpsk_snr_est_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_mpsk_snr_est_cc_sptr
        __init__(self,  p) -> digital_mpsk_snr_est_cc_sptr
        """
        this = _digital_swig.new_digital_mpsk_snr_est_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_mpsk_snr_est_cc_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> double

        Return the estimated signal-to-noise ratio in decibels.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_snr(self)

    def type(self):
        """
        type(self) -> snr_est_type_t

        Return the type of estimator in use.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_type(self)

    def tag_nsample(self):
        """
        tag_nsample(self) -> int

        Return how many samples between SNR tags.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_tag_nsample(self)

    def alpha(self):
        """
        alpha(self) -> double

        Get the running-average coefficient.

        Params: (NONE)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(self, snr_est_type_t t)

        Set type of estimator to use.

        Params: (t)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_type(self, *args, **kwargs)

    def set_tag_nsample(self, *args, **kwargs):
        """
        set_tag_nsample(self, int n)

        Set the number of samples between SNR tags.

        Params: (n)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_tag_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, double alpha)

        Set the running-average coefficient.

        Params: (alpha)
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_check_topology(self, *args, **kwargs)

digital_mpsk_snr_est_cc_sptr_swigregister = _digital_swig.digital_mpsk_snr_est_cc_sptr_swigregister
digital_mpsk_snr_est_cc_sptr_swigregister(digital_mpsk_snr_est_cc_sptr)

digital_mpsk_snr_est_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def mpsk_snr_est_cc(*args, **kwargs):
  """
    mpsk_snr_est_cc(snr_est_type_t type, int tag_nsamples = 10000, double alpha = 0.001) -> digital_mpsk_snr_est_cc_sptr

    A block for computing SNR of a signal.

    This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

    The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Factory function returning shared pointer of this class

    Parameters:

    Params: (type, tag_nsamples, alpha)
    """
  return _digital_swig.mpsk_snr_est_cc(*args, **kwargs)
class digital_ofdm_cyclic_prefixer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_cyclic_prefixer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_cyclic_prefixer_sptr
        __init__(self,  p) -> digital_ofdm_cyclic_prefixer_sptr
        """
        this = _digital_swig.new_digital_ofdm_cyclic_prefixer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_cyclic_prefixer_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_cyclic_prefixer_sptr_swigregister = _digital_swig.digital_ofdm_cyclic_prefixer_sptr_swigregister
digital_ofdm_cyclic_prefixer_sptr_swigregister(digital_ofdm_cyclic_prefixer_sptr)

digital_ofdm_cyclic_prefixer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_cyclic_prefixer(*args, **kwargs):
  """
    ofdm_cyclic_prefixer(size_t input_size, size_t output_size) -> digital_ofdm_cyclic_prefixer_sptr

    adds a cyclic prefix vector to an input size long ofdm symbol(vector) and converts vector to a stream output_size long.

    Params: (input_size, output_size)
    """
  return _digital_swig.ofdm_cyclic_prefixer(*args, **kwargs)
class digital_ofdm_frame_acquisition_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_frame_acquisition)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_frame_acquisition_sptr
        __init__(self,  p) -> digital_ofdm_frame_acquisition_sptr
        """
        this = _digital_swig.new_digital_ofdm_frame_acquisition_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_frame_acquisition_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> float

        Return an estimate of the SNR of the channel.

        Params: (NONE)
        """
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_snr(self)

    def general_work(self, *args, **kwargs):
        """
        general_work(self, int noutput_items, gr_vector_int ninput_items, gr_vector_const_void_star input_items, 
            gr_vector_void_star output_items) -> int

        Params: (noutput_items, ninput_items, input_items, output_items)
        """
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_general_work(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_frame_acquisition_sptr_swigregister = _digital_swig.digital_ofdm_frame_acquisition_sptr_swigregister
digital_ofdm_frame_acquisition_sptr_swigregister(digital_ofdm_frame_acquisition_sptr)

digital_ofdm_frame_acquisition_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_frame_acquisition(*args, **kwargs):
  """
    ofdm_frame_acquisition(unsigned int occupied_carriers, unsigned int fft_length, 
        unsigned int cplen, gr_complex_vector known_symbol, 
        unsigned int max_fft_shift_len = 4) -> digital_ofdm_frame_acquisition_sptr

    take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

    This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

    It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.

    Params: (occupied_carriers, fft_length, cplen, known_symbol, max_fft_shift_len)
    """
  return _digital_swig.ofdm_frame_acquisition(*args, **kwargs)
class digital_ofdm_frame_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_frame_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_frame_sink_sptr
        __init__(self,  p) -> digital_ofdm_frame_sink_sptr
        """
        this = _digital_swig.new_digital_ofdm_frame_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_frame_sink_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_frame_sink_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_frame_sink_sptr_swigregister = _digital_swig.digital_ofdm_frame_sink_sptr_swigregister
digital_ofdm_frame_sink_sptr_swigregister(digital_ofdm_frame_sink_sptr)

digital_ofdm_frame_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_frame_sink(*args, **kwargs):
  """
    ofdm_frame_sink(gr_complex_vector sym_position, __dummy_0__ sym_value_out, 
        gr_msg_queue_sptr target_queue, unsigned int occupied_tones, 
        float phase_gain = 0.25, 
        float freq_gain = 0.25*0.25/4) -> digital_ofdm_frame_sink_sptr

    Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

    NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.

    Params: (sym_position, sym_value_out, target_queue, occupied_tones, phase_gain, freq_gain)
    """
  return _digital_swig.ofdm_frame_sink(*args, **kwargs)
class digital_ofdm_insert_preamble_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_insert_preamble)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_insert_preamble_sptr
        __init__(self,  p) -> digital_ofdm_insert_preamble_sptr
        """
        this = _digital_swig.new_digital_ofdm_insert_preamble_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_insert_preamble_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_insert_preamble_sptr_swigregister = _digital_swig.digital_ofdm_insert_preamble_sptr_swigregister
digital_ofdm_insert_preamble_sptr_swigregister(digital_ofdm_insert_preamble_sptr)

digital_ofdm_insert_preamble_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_insert_preamble(*args, **kwargs):
  """
    ofdm_insert_preamble(int fft_length, std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)> preamble) -> digital_ofdm_insert_preamble_sptr

    insert "pre-modulated" preamble symbols before each payload.

    Params: (fft_length, preamble)
    """
  return _digital_swig.ofdm_insert_preamble(*args, **kwargs)
class digital_ofdm_mapper_bcv_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_mapper_bcv)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_mapper_bcv_sptr
        __init__(self,  p) -> digital_ofdm_mapper_bcv_sptr
        """
        this = _digital_swig.new_digital_ofdm_mapper_bcv_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_mapper_bcv_sptr
    __del__ = lambda self : None;
    def msgq(self):
        """
        msgq(self) -> gr_msg_queue_sptr

        Params: (NONE)
        """
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_msgq(self)

    def work(self, *args, **kwargs):
        """
        work(self, int noutput_items, gr_vector_const_void_star input_items, 
            gr_vector_void_star output_items) -> int

        Params: (noutput_items, input_items, output_items)
        """
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_work(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_mapper_bcv_sptr_swigregister = _digital_swig.digital_ofdm_mapper_bcv_sptr_swigregister
digital_ofdm_mapper_bcv_sptr_swigregister(digital_ofdm_mapper_bcv_sptr)

digital_ofdm_mapper_bcv_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_mapper_bcv(*args, **kwargs):
  """
    ofdm_mapper_bcv(gr_complex_vector constellation, unsigned int msgq_limit, 
        unsigned int bits_per_symbol, unsigned int fft_length) -> digital_ofdm_mapper_bcv_sptr

    take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator. Abstract class must be subclassed with specific mapping.

    Params: (constellation, msgq_limit, occupied_carriers, fft_length)
    """
  return _digital_swig.ofdm_mapper_bcv(*args, **kwargs)
class digital_ofdm_sampler_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_sampler)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_sampler_sptr
        __init__(self,  p) -> digital_ofdm_sampler_sptr
        """
        this = _digital_swig.new_digital_ofdm_sampler_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_sampler_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_sampler_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_sampler_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_sampler_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_sampler_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_sampler_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_sampler_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_sampler_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_sampler_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_sampler_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_sampler_sptr_swigregister = _digital_swig.digital_ofdm_sampler_sptr_swigregister
digital_ofdm_sampler_sptr_swigregister(digital_ofdm_sampler_sptr)

digital_ofdm_sampler_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_sampler(*args, **kwargs):
  """
    ofdm_sampler(unsigned int fft_length, unsigned int symbol_length, 
        unsigned int timeout = 1000) -> digital_ofdm_sampler_sptr

    does the rest of the OFDM stuff

    Params: (fft_length, symbol_length, timeout)
    """
  return _digital_swig.ofdm_sampler(*args, **kwargs)
class digital_probe_mpsk_snr_est_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_probe_mpsk_snr_est_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_probe_mpsk_snr_est_c_sptr
        __init__(self,  p) -> digital_probe_mpsk_snr_est_c_sptr
        """
        this = _digital_swig.new_digital_probe_mpsk_snr_est_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_probe_mpsk_snr_est_c_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> double

        Return the estimated signal-to-noise ratio in decibels.

        Params: (NONE)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_snr(self)

    def type(self):
        """
        type(self) -> snr_est_type_t

        Return the type of estimator in use.

        Params: (NONE)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_type(self)

    def msg_nsample(self):
        """
        msg_nsample(self) -> int

        Return how many samples between SNR messages.

        Params: (NONE)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_msg_nsample(self)

    def alpha(self):
        """
        alpha(self) -> double

        Get the running-average coefficient.

        Params: (NONE)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(self, snr_est_type_t t)

        Set type of estimator to use.

        Params: (t)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_type(self, *args, **kwargs)

    def set_msg_nsample(self, *args, **kwargs):
        """
        set_msg_nsample(self, int n)

        Set the number of samples between SNR messages.

        Params: (n)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_msg_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, double alpha)

        Set the running-average coefficient.

        Params: (alpha)
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_check_topology(self, *args, **kwargs)

digital_probe_mpsk_snr_est_c_sptr_swigregister = _digital_swig.digital_probe_mpsk_snr_est_c_sptr_swigregister
digital_probe_mpsk_snr_est_c_sptr_swigregister(digital_probe_mpsk_snr_est_c_sptr)

digital_probe_mpsk_snr_est_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def probe_mpsk_snr_est_c(*args, **kwargs):
  """
    probe_mpsk_snr_est_c(snr_est_type_t type, int msg_nsamples = 10000, double alpha = 0.001) -> digital_probe_mpsk_snr_est_c_sptr

    A probe for computing SNR of a signal.

    This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Factory function returning shared pointer of this class

    Parameters:

    Params: (type, msg_nsamples, alpha)
    """
  return _digital_swig.probe_mpsk_snr_est_c(*args, **kwargs)
class digital_cpmmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_cpmmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_cpmmod_bc_sptr
        __init__(self,  p) -> digital_cpmmod_bc_sptr
        """
        this = _digital_swig.new_digital_cpmmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_cpmmod_bc_sptr
    __del__ = lambda self : None;
    def get_taps(self):
        """
        get_taps(self) -> __dummy_4__

        Return the phase response FIR taps.

        Params: (NONE)
        """
        return _digital_swig.digital_cpmmod_bc_sptr_get_taps(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_cpmmod_bc_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_cpmmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_cpmmod_bc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_cpmmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_cpmmod_bc_sptr_check_topology(self, *args, **kwargs)

digital_cpmmod_bc_sptr_swigregister = _digital_swig.digital_cpmmod_bc_sptr_swigregister
digital_cpmmod_bc_sptr_swigregister(digital_cpmmod_bc_sptr)

digital_cpmmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def cpmmod_bc(*args, **kwargs):
  """
    cpmmod_bc(int type, float h, unsigned int samples_per_sym, unsigned int L, 
        double beta = 0.3) -> digital_cpmmod_bc_sptr

    Generic CPM modulator.

    Examples:


    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Params: (type, h, samples_per_sym, L, beta)
    """
  return _digital_swig.cpmmod_bc(*args, **kwargs)
class digital_gmskmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_gmskmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_gmskmod_bc_sptr
        __init__(self,  p) -> digital_gmskmod_bc_sptr
        """
        this = _digital_swig.new_digital_gmskmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_gmskmod_bc_sptr
    __del__ = lambda self : None;
    def get_taps(self):
        """get_taps(self) -> __dummy_4__"""
        return _digital_swig.digital_gmskmod_bc_sptr_get_taps(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_gmskmod_bc_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_gmskmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_gmskmod_bc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_gmskmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_gmskmod_bc_sptr_check_topology(self, *args, **kwargs)

digital_gmskmod_bc_sptr_swigregister = _digital_swig.digital_gmskmod_bc_sptr_swigregister
digital_gmskmod_bc_sptr_swigregister(digital_gmskmod_bc_sptr)

digital_gmskmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def gmskmod_bc(samples_per_sym = 2, bt = 0.3, L = 4):
  """
    gmskmod_bc(unsigned int samples_per_sym = 2, double bt = 0.3, 
        unsigned int L = 4) -> digital_gmskmod_bc_sptr

    GMSK modulator.

    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Params: (samples_per_sym, bt, L)
    """
  return _digital_swig.gmskmod_bc(samples_per_sym, bt, L)


